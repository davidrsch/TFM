{"title":"Anexo. 4 Códigos","markdown":{"headingText":"Anexo. 4 Códigos","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\nA continuación preséntase o código utilizado para realizar o procedemento descrito no desenvolvemento do traballo.\n\n## Datos\n\n### Recollida de datos {#sec-A-obtdat}\n\nO primeiro que se fixo foi cargar a táboa de empresas.\n\n```{r}\n#| eval: false\nlibrary(readxl)\nempresas <- read_excel(\"data/000_empresas.xlsx\")\n```\n\nDespois extraíanse as carrachas das empresas.\n\n```{r}\n#| eval: false\nlibrary(dplyr)\nticks <- empresas |> \n  select(TICKERS) |> \n  pull()\n```\n\nUnha vez almacenados os ticks das empresas na variable `ticks`, os datos correspondentes a ditas empresas foron descargados de Yahoo Finance mediante o paquete quantmod de @quantmod23.\n\n```{r}\n#| eval: false\nlibrary(quantmod)\nnombres_colum <- c(\"Date\",\"Open\",\"High\",\"Low\",\"Close\",\"Volume\",\"Adjusted\")\nqmd_data <- list()\nfor (i in 1:length(ticks)) {\n  tick <- ticks[i]\n  value <- getSymbols(\n    tick,\n    from = \"2000-01-02\",\n    to = \"2023-03-01\",\n    auto.assign = F,\n    periodicity = \"monthly\") |>\n    as.data.frame()\n  dates <- row.names(value)\n  row.names(value) <- NULL\n  value <- cbind(dates,value)\n  names(value) <- nombres_colum\n  qmd_data[[tick]] <-  value\n}\n```\n\nCo obxectivo de realizar unha análise exploratoria dos datos, optouse por realizar unha avaliación visual dos datos históricos do prezo axustado polo que se executou:\n\n```{r}\n#| eval: false\nlapply(qmd_data, function(x){\n  x |>\n    ggplot(aes(x=as.Date(Date), y=Adjusted))+\n             geom_line(color=\"#065AD8\")\n})\n```\n\nTras a análise visual realizada co fragmento de código anterior detectouse a existencia de prezos constantes, así como cálculos erróneos no prezo axustado correspondente aos primeiros anos dalgunha serie. Para eliminar estas irregularidades, só se seleccionaron aquelas observacións posteriores a xaneiro de 2005.\n\n```{r}\n#| eval: false\nreturns_emps <- qmd_data |>\n  lapply(function(x){\n    emps <- x |>\n      filter(Date >= \"2005-01-31\")\n  })\n```\n\nPara determinar se os datos que foran importados tiñan valores que faltaban, executouse o seguinte código:\n\n```{r}\n#| eval: false\nna_values <- returns_emps |>\n  sapply(function(x){\n    na <- length(which(is.na(x)))\n  })\nemp_con_na <- which(na_values > 0)\n```\n\nPara solucionar o problema de rexistro incorrecto dos datos, optouse por eliminar aqueles que non presentasen variacións de prezo en máis de 10 observacións. Para o cal, os retornos calculáronse primeiro executando o seguinte código, mediante o cal tamén se eliminaron as series con valores ausentes.\n\n```{r}\n#| eval: false\nreturns_emps2 <- returns_emps[-emp_con_na] |>\n  lapply(function(x){\n    returns <- x |>\n      select(Date, Adjusted) |>\n      mutate(Return_Ad = Delt(Adjusted)[,1]) |>\n      na.omit() |>\n      select(Date, Return_Ad)\n  })\n```\n\nUnha vez computados os retornos, elimináronse aquelas series que presentaban 0 retornos en máis de 10 observacións, para o que se executou o seguinte código.\n\n```{r}\n#| eval: false\nzero_values <- returns_emps2 |>\n  sapply(function(x){\n    zeros <- length(which(x[,2]==0))\n  })\nreturns_emps3 <- returns_emps2[zero_values<10]\n```\n\n### Indicadores {#sec-A-indi}\n\nA continuación móstrase o código utilizado durante o proceso descrito no subtítulo de indicadores do capítulo 2.\n\nEn primeiro lugar, descargáronse os datos do IBEX, calculáronse os rendementos do prezo axustado dos mesmos e seleccionáronse os valores posteriores a xaneiro de 2005.\n\n```{r}\n#| eval: false\n\n#Importando IBEX\nIBEXsel <- getSymbols(\n  \"^IBEX\",\n  from = \"1990-01-01\",\n  to = \"2023-03-01\",\n  auto.assign = F,\n  periodicity = \"monthly\") |>\n  as.data.frame()\ndates <- row.names(IBEXsel)\nrow.names(IBEXsel) <- NULL\nIBEXsel <- cbind(dates,IBEXsel)\nnames(IBEXsel) <- nombres_colum\n# Cálculo da rendibilidade e selección de observacións despois\n# Xaneiro 2005.\nIBEXsel <- IBEXsel |>\n  mutate(Return_I = Delt(Adjusted)[,1]) |>\n  na.omit() |>\n  filter(Date >= \"2005-01-31\") |>\n  select(Date, Return_I)\n```\n\nA continuación, engadíronse os valores das rendibilidades do IBEX ás táboas de rendibilidade das accións das empresas seleccionadas, e calculáronse e engadíronse a cada unha das táboas as variables que se enumeran a continuación:\n\n-   Volatilidade da empresa\n-   Volatilidade do índice\n-   Correlación entre a rendibilidade da empresa e o índice\n-   A Beta entre a empresa e o índice\n\n```{r}\n#| eval: false\n\nreturns_indc <- returns_emps3 |>\n  lapply(function(x, ind = IBEXsel){\n    emp <- x |>\n      left_join(ind) |>\n      mutate(\n        VE = sqrt(cumsum((Return_Ad - cummean(Return_Ad))^2)/1:length(Return_Ad)),\n        VI = sqrt(cumsum((Return_I - cummean(Return_I))^2)/1:length(Return_I)),\n        Cor = cumsum((Return_Ad-cummean(Return_Ad))*(Return_I-cummean(Return_I)))/(sqrt(cumsum((Return_Ad-cummean(Return_Ad))^2))*sqrt(cumsum((Return_I-cummean(Return_I))^2)))\n      )|>\n      na.omit() |>\n      mutate(\n        Beta = (Cor*VE)/VI\n      )\n  })\n```\n\n### Vectores {#sec-A-vec}\n\nA continuación móstrase o código utilizado durante o proceso descrito no subtítulo de vectores do título de modelado do capítulo 2.\n\nO primeiro paso realizado para a execución do proceso explicado no subepígrafe en cuestión foi a creación dunha función que permitise obter as mostras consecutivas para cada serie utilizada. A función que se presenta a continuación, como xa se dixo, permite obter as mostras consecutivas dunha serie, para as que se utilizan os parámetros mencionados no subtítulo, número de observacións de entrada e número de observacións de saída, así como un parámetro condicional co que se indícase se o vector que se vai crear é de entrada ou de saída.\n\n```{r}\n#| eval: false\n\nvector2dmaker <- function(vec, ent, sal, eos=T){\n  if(eos==T){\n    emp <- 1\n    term <- (length(vec) - (ent+sal-1))\n    ob <- ent\n  }else{\n    emp <- ent + 1\n    term <- (length(vec)-sal+1)\n    ob <- sal\n  }\n  \n  vec2d <- sapply(emp:term,\n               function(x) vec[x:(x + ob-1)]) |>\n    matrix(nrow = ob) |>\n    t()\n  \n  return(vec2d)\n}\n```\n\nA continuación móstrase o código utilizado para crear os vectores de entrada correspondentes a cada unha das series. Para o cal se crearon primeiro dúas funcións, unha para as entradas e outra para as saídas.\n\n```{r}\n#| eval: false\n\n# Función que se utilizará para crear as entradas tridimensionais\ninput3dmaker <- function(x,inp,out){\n  empre <- x\n  series <- 2:dim(x)[2]\n  for (i in series) {\n    if(i==series[1]){\n      vec3d <- vector2dmaker(empre[[i]],ent=inp,sal=out)\n    }else{\n      vec3d <- abind(vec3d,vector2dmaker(empre[[i]],ent=inp,sal=out), along = 3)\n    }\n  }\n  return(vec3d)\n}\n\n# Función que se utilizará para crear as saídas tridimensionais\noutput3dmaker <- function(x,inp,out){\n  empre <- x[[\"Return_Ad\"]]\n  vec3d <- vector2dmaker(empre,ent=inp,sal=out,F)\n  dim(vec3d) <- c(dim(vec3d),1)\n  return(vec3d)\n}\n```\n\nDespois creáronse as listas de vectores tridimensionais de entradas e saídas por empresa, executando outras dúas veces o seguinte código co obxectivo de crear as listas `vecs3d2e` e `vecs3d3e` que se corresponden con aqueles casos nos que foron 2 e 3 entradas. seleccionados.\n\n```{r}\n#| eval: false\n\n# O horizonte temporal está definido\nht <- 1\n\n# Defínense as observacións de entrada\noe <- 1\n\n# Os vectores de entrada 3D créanse para o tamaño de entrada 1\nvecs3d1e <- list()\nfor(i in 1:length(returns_indc)){\n  emp <- returns_indc[[i]]\n  inps <- input3dmaker(emp, oe, ht)\n  outs <- output3dmaker(emp, oe, ht)\n  dates <- emp[(oe + ht):dim(emp)[1],1]\n  id <- rep(names(returns_indc)[i],length(dates))\n  tibblex <- tibble(\n    Date = dates,\n    ID = id,\n    inputs = inps,\n    outputs = outs\n  )\n  vecs3d1e[[names(returns_indc)[i]]] <- tibblex\n}\n```\n\n## Modelado e formación\n\nA continuación preséntase o código utilizado durante o proceso descrito nas diferentes subseccións da sección Modelado e formación.\n\n### Modelado {#sec-A-modelos}\n\nPara a creación dos modelos, o primeiro paso a executar é obter a información dos vectores para os que se vai construír o modelo, o que se fixo executando o seguinte código:\n\n```{r}\n#| eval: false\n\ndata <- bind_rows(vecs3d1e)\ndata <- data  |>\n  arrange(Date)\ninputsinfo <- data|>\n  select(inputs) |>\n  pull() |>\n  dim()\noutputsinfo <- data|>\n  select(outputs) |>\n  pull() |>\n  dim()\n\n# Definir parámetros\nn_ob_pas <- inputsinfo[2]\nn_variables <- inputsinfo[3]\nn_ob_fut <- outputsinfo[2]\n\n```\n\nDespois constituíuse a estrutura dos modelos cos aspectos descritos en @sec-modelado.\n\n```{r}\n#| eval: false\n\n# Capa de entrada\ninp <- layer_input(\n  shape = c(NULL,n_ob_pas,n_variables))\n\n# Capas ocultas\n# - CNN\ncnn <- inp |>\n  layer_conv_1d(\n    filters = 64,\n    kernel_size = 1,\n    activation = layer_activation_leaky_relu())\n# - LSTM\nlstm <- cnn |>\n  layer_lstm(64)\n\n# Capa de Salida\nout <- lstm |> \n  layer_dense(\n    n_ob_fut*1)\n\n# Unir as capas para constituír o modelo\nmodel <- keras_model(inp, out)\n# Establecemento de parámetros de aprendizaxe\nmodel |> \n  compile(loss = \"mse\", optimizer = optimizer_sgd(0.0005))\n```\n\n*Nota:* Podes atopar modelos non adestrados no cartafol `data` do repositorio onde se atopa este traballo. Os modelos gardáronse usando a extensión `hdf5` e baixo os nomes `model1e`, `model2e` e `model3e`.\n\n### Formación {#sec-A-entrenamiento}\n\nO primeiro paso é definir a función a utilizar para adestrar os modelos. Esta función creouse co obxectivo de utilizar o método de adestramento descrito en @sec-training. Como resultado, esta función devolverá unha lista que conterá as predicións obtidas e o modelo despois de ter sido adestrado e tomará como entradas principais o tibble denominado `datos` constituído no primeiro paso que se expón en @sec-A-modelos e o modelo tamén. doutros argumentos que permitan o uso da función con algunhas entradas principais que non se utilizan no presente traballo.\n\n```{r}\n#| eval: false\nwfv_train <- function(x, modelo, seq_var_name, inp_var_name = \"inputs\", out_var_name = \"outputs\", progress_bar=T){\n  \n  predictions <- c()\n  seq_val <- unique(x[[seq_var_name]])\n  \n  if(progress_bar){\n    pb <- txtProgressBar(min = 0, max = length(seq_val), initial = 0, style = 3)\n  }\n  \n  \n  # Iteración que se executará para cada valor único na variable que define a secuencia de datos. Por este motivo é de vital importancia que os datos en tibble x estean ordenados pola variable de secuencia cuxo nome se pasa a seq_var_name\n  \n  for (i in 1:length(seq_val)) {\n    val_seq <- seq_val[i]\n    # Extraer entradas e saídas correspondentes ao período na variable secuencia actual\n    inputs <- x |>\n      filter(!!sym(seq_var_name) == val_seq) |>\n      select(!!sym(inp_var_name)) |>\n      pull()\n    outputs <- x |>\n      filter(!!sym(seq_var_name) == val_seq) |>\n      select(!!sym(out_var_name)) |>\n      pull()\n    outputs <- outputs[,,1]\n    \n    # Use entradas para obter previsións para todos os períodos da variable secuencia excepto o primeiro\n    if(i > 1){\n      pred <- modelo |>\n        predict(inputs, verbose = 3)\n      predictions <- rbind(predictions, pred)\n    }\n    \n    # Adestrar o modelo\n    modelo |>\n      fit(\n        inputs,\n        outputs,\n        epochs = 1,\n        batch_size = 10,\n        shuffle = F,\n        verbose = 0)\n    \n    if(progress_bar){\n      setTxtProgressBar(pb,i)\n      }\n    \n  }\n  \n  if(progress_bar){\n    close(pb)\n  }\n  \n  results <- list()\n  results[['predicciones']] <- predictions\n  results[['modelo']] <- modelo\n  return(results)\n}\n\n```\n\nUnha vez creada a función, obtivéronse as predicións mediante o seguinte código:\n\n```{r}\n#| eval: false\n\nresultados <- wfv_train(data,model,'Date')\npredicciones1e <- resultados$predicciones\n```\n\n*Nota:* Podes atopar modelos adestrados no cartafol `data` do repositorio onde se atopa este traballo. Os modelos gardáronse usando a extensión `hdf5` e baixo os nomes `model1etd`, `model2etd` e `model3etd`.\n\nSegundo se explica en @sec-predicciones, ademais das predicións obtidas polos modelos, calculáronse predicións obtidas a partir do uso da media aritmética, para comparar coas obtidas cos modelos. Para calcular estas predicións, creouse a seguinte función:\n\n```{r}\n#| eval: false\n\nwfv_means <- function(x, seq_var_name, inp_var_name = \"inputs\", out_var_name = \"outputs\", id_var_name, progress_bar=T){\n  \n  means <- c()\n  seq_val <- unique(x[[seq_var_name]])\n  \n  if(progress_bar){\n    pb <- txtProgressBar(min = 0, max = length(seq_val), initial = 0, style = 3)\n  }\n  \n  for (i in 1:length(seq_val)) {\n    val_seq <- seq_val[i]\n    inputs <- x |>\n      filter(!!sym(seq_var_name) == val_seq) |>\n      select(!!sym(inp_var_name)) |>\n      pull()\n    inputspred <- x |>\n      filter(!!sym(seq_var_name) == val_seq) |>\n      select(!!sym(inp_var_name)) |>\n      pull()\n    outputs <- x |>\n      filter(!!sym(seq_var_name) == val_seq) |>\n      select(!!sym(out_var_name)) |>\n      pull()\n    outputs <- outputs[,,1]\n    \n    ids <- x |>\n      filter(!!sym(seq_var_name) == val_seq) |>\n      select(!!sym(id_var_name)) |>\n      pull()\n    \n    if(i==1){\n      dfmeans <- inputs[,,1] |>\n        as.data.frame() |>\n        cbind(ID = ids)\n    }else{\n      dfmeansupd <- inputs[,dim(inputs)[2],1] |>\n        as.data.frame() |>\n        cbind(ID = ids)\n      names(dfmeansupd)[1] <- paste0(\"V\",(dim(dfmeans)[2]))\n      idsdf <- unique(c(ids, dfmeans[[id_var_name]]))\n      idsdf <- data.frame(ID = idsdf)\n      dfmeansupd <- dplyr::left_join(idsdf, dfmeansupd, by = \"ID\")\n      ifelse(\n        dim(dfmeansupd)[1] > dim(dfmeans)[1],\n        dfmeans <- dplyr::left_join(dfmeansupd, dfmeans, by = \"ID\"),\n        dfmeans <- dplyr::left_join(dfmeans, dfmeansupd, by = \"ID\")\n        )\n    }\n    \n    if(i > 1){\n      MEANS <-  dfmeans |>\n        rowwise() |>\n        mutate(\n          means = mean(c_across(-!!sym(id_var_name)), na.rm = T)) |>\n        slice(match(ids,!!sym(id_var_name))) |>\n        pull(means) |>\n        as.matrix()\n      means <- rbind(means, MEANS)\n    }\n    \n    if(progress_bar){\n      setTxtProgressBar(pb,i)\n    }\n    \n  }\n  \n  if(progress_bar){\n    close(pb)\n  }\n  \n  return(means)\n}\n\n```\n\nUnha vez creada a función, obtivéronse as predicións mediante o seguinte código:\n\n```{r}\n#| eval: false\n\nmeanse1 <- wfv_train(data,'Date',id_var_name = \"ID\")\n```\n\n*Nota:* Ademais do exposto anteriormente, no ficheiro .Rprofile do repositorio no que se atopa este traballo creáronse dúas funcións `getconfig` e `plot_modelk` que permiten representar gráficamente a estrutura dos modelos mediante o paquete @Diagrammer, como visto nas @fig-structures. O código a usar sería:\n\n```{r}\n#| eval: false\n\n# As funcións créanse para representar gráficamente as estruturas utilizadas neste traballo.\nmodel |>\n  getconfig() |>\n  plot_modelk() |>\n  grViz()\n```\n\nRepetiuse o procedemento exposto nas seccións @sec-A-models e @sec-A-training para construír os 10 modelos feitos a partir de cada grupo de vectores tridimensionais, substituíndo a chamada a `vecs3d1e` por `no primeiro código exposto. .vecs3d2e` e `vecs3d3e`, dependendo do grupo de vectores tridimensionais utilizados.\n\n## Resultado\n\nA continuación preséntase o código utilizado durante o proceso descrito nas diferentes subseccións da sección de Resultados.\n\n### Predicións {#sec-A-predicciones}\n\nA análise exposta nas prediccións @sec-realizouse a partir de gráficos (ver @fig-ind_evo_oo, @fig-ind_evo_twoo e @fig-ind_evo_threeo), nos que se recollen os valores dos indicadores MSE e $R^2$ para cada unha das estruturas ensaiadas.\n\nO primeiro paso para obter estas gráficas foi o cálculo dos indicadores, para cada período de tempo, para cada unha das predicións obtidas a partir dos distintos modelos construídos con cada estrutura. Isto faise usando o seguinte código.\n\n```{r}\n#| eval: false\n\n# Extraer os resultados reais\nsalidas <- data |>\n  filter(\n    Date > data$Date[1]\n  ) |>\n  select(outputs) |>\n  pull()\nsalidas <- salidas[,,1]\n\n# Calcular os indicadores MSE e R2\nindicadores <- data |>\n  filter(Date > data$Date[1]) |>\n  cbind(predicciones = predicciones1e[,1]) |>\n  cbind(means = meanse1) |>\n  mutate(salidas = salidas) |>\n  select(Date, predicciones, means, salidas) |>\n  group_by(Date) |>\n  summarise(\n    r2 = 1 - (sum((salidas - predicciones)^2)/sum((salidas - means)^2)),\n    mse = mse(predicciones, salidas),\n  )\n```\n\nOs diferentes indicadores calculados para cada un dos 10 modelos adestrados con cada unha das estruturas foron almacenados nunha lista denominada `list_indicadores`. Isto faise usando o seguinte código:\n\n```{r}\n#| eval: false\n\nlist_indicadores[[\"indicadores1\"]] <-  indicadores\n```\n\nFeito isto, obtense unha lista que contén 10 marcos de datos (`indicadores1`,...,`indicadores10`), que á súa vez conteñen os valores dos de MSe e $R^2$ das predicións obtidas. por modelos de ARN para cada unha das empresas agrupadas por data. Entón, a gráfica foi construída usando o seguinte código.\n\n```{r}\n#| eval: false\n\n# Agrupar a información das distintas construcións nun único marco de datos\nindi_graf_data <- do.call(cbind,list_indicadores)\n\n# Obter os resultados medios, para cada período de tempo, utilizando as distintas construcións\nindi_graf_data |>\n  rowwise() |>\n  mutate(\n    Date = `indicadores1.Date`,\n    meanmse = mean(c_across(contains(\"mse\"))),\n    meanr2 = mean(c_across(contains(\"r2\")))\n    ) |>\n  select(\n    Date, meanmse,meanr2\n  )|>\n  # Gráfico\n  mutate(\n    Date = as.Date(Date)) |>\n  ggplot(aes(x = Date, group = 1)) +\n  geom_line(aes(y = meanmse, color = \"MSE\")) +\n  geom_line(aes(y = meanr2, color = \"R2\")) +\n  scale_color_manual(values = c(\"blue\", \"green\")) +\n  theme(axis.text.x = element_text(angle = 90)) +\n  labs(x = \"Fecha\", y = \"Valores\", color = \"Indicadores\")\n\n```\n\nAdemais das gráficas, na análise dos resultados tamén se utilizou o @tbl-indicadores, nos que se sitúan as empresas que obtiveron os mellores e peores indicadores para cada estrutura Para a obtención destes datos utilizouse o seguinte código:\n\n```{r}\n#| eval: false\n\nindicadores_X_emp <- data |>\n  filter(Date > data$Date[1]) |>\n  cbind(predicciones = predicciones1e[,1]) |>\n  cbind(means = meanse1) |>\n  mutate(salidas = salidas) |>\n  select(Date, predicciones, means, salidas, ID) |>\n  group_by(ID) |>\n  summarise(\n    r2 = 1 - (sum((salidas - predicciones)^2)/sum((salidas - means)^2)),\n    mse = mse(predicciones, salidas)\n  ) |>\n  select(ID, r2, mse)\n```\n\nDo mesmo xeito que os indicadores calculados por data, para gardar os indicadores calculados por empresa, creouse unha lista chamada `list_indic_emp`. Despois de ter almacenados os 10 marcos de datos indicadores por empresa na lista, extraéronse as empresas con mellores e peores resultados mediante o seguinte código:\n\n```{r}\n#| eval: false\n\n# Agrupar a información das distintas construcións nun único marco de datos\nind_emp_t <- do.call(rbind, list_indic_emp)\n\n# Calcula a media R2 e MSE por empresa\nind_emp_t <- ind_emp_t |>\n  group_by(ID) |>\n  summarize(\n    r2 = mean(r2),\n    mse= mean(mse)) |>\n  ungroup() |>\n  arrange(desc(r2))\n\n# Obtén as 10 empresas cos mellores e peores indicadores\nmejores10 <- head(ind_emp_t,10)\npeores10 <- tail(ind_emp_t,10)\n```\n\nE usando as variables anteriores e as funcións `rbind()` e `cbind`, creouse a @tbl-indicadores.\n\n### Composición de carteiras {#sec-A-cc}\n\nNeste apartado explícase como se realizou a análise da comparación dos resultados obtidos polas diferentes carteiras (ver @fig-pf_evo_oo, @fig-pf_evo_twoo e @fig-pf_evo_threeo). Para iso, primeiro cómpre obter a composición das carteiras, por datas, a partir das predicións obtidas mediante a utilización das medias aritméticas e dos modelos de ARN.\n\nPara calcular a composición das carteiras utilizouse o paquete R @quadprog. A continuación móstrase o código utilizado para atopar a composición das carteiras a partir das predicións da media:\n\n```{r}\n#| eval: false\n\n# Creouse un marco de datos no que se almacenaba toda a información:\n#   - Valores IBEX, como índice de referencia\n#   - Valores das predicións, tanto os obtidos polo modelo de ARN como polas medias aritméticas\n\nDATA <- data |>\n  left_join(IBEXsel, by =\"Date\") |>\n  mutate(IBEX = Return_I) |>\n  arrange(Date) |>\n  filter(\n    Date > data$Date[1]\n  ) |>\n  mutate(predicciones = predicciones1e[,1]) |>\n  mutate(\n    Real = salidas,\n    RNA = predicciones,\n    Means = meanse1\n  ) |>\n  select(Date, Real, IBEX, RNA, Means, ID)\n\n# A partir do marco de datos creáronse DATA:\n#    - Un marco de datos cuxas columnas son os datos reais de cada unha das empresas para cada un dos períodos de tempo para os que se obtiveron predicións.\n#    - Un marco de datos cuxas columnas son os datos obtidos mediante a utilización das medias aritméticas de cada unha das empresas para cada un dos períodos de tempo para os que se obtiveron predicións.\n\npvtReal <- DATA |>\n  select(Date, Real, ID) |>\n  pivot_wider(\n    names_from = ID,\n    values_from = Real\n  )\n\npvtMeans <- DATA |>\n  select(Date, Means, ID) |>\n  pivot_wider(\n    names_from = ID,\n    values_from = Means\n  )\n\n# Creouse o marco de datos no que se almacenaba a composición das carteiras para cada un dos períodos para os que se obtivo a predición\nweightsm <- data.frame()\n\n# Iteración pola que se atopa a composición das carteiras\n\npb <- txtProgressBar(min = 0, max = length(unique(data$Date)[-1]), initial = 0, style = 3)\n\nfor (i in 1:length(unique(data$Date)[-1])) {\n  if(i>1){\n    \n    # Créase o marco de datos que inclúe os datos a utilizar para atopar a composición da carteira, esta é creada polos datos reais ata a data e a previsión para o próximo período\n    \n    datamQP <- pvtReal |>\n      filter(Date < unique(data$Date)[-1][i]) |>\n      rbind(pvtMeans |>\n              filter(Date == unique(data$Date)[-1][i])\n      )\n    \n    # Elimina aquelas empresas que non teñan datos reais ou previstos\n    \n    nare <- which(is.na(datamQP[dim(datamQP)[1],]))\n    naremo <- which(is.na(datamQP[(dim(datamQP)[1]-1),]))\n    nare <- c(nare,naremo)\n    nare <- unique(nare)\n    if(length(nare) != 0){\n      carteram <- datamQP[, - nare]\n    }else{\n      carteram <- datamQP\n    }\n    \n    # Extraer previsións\n    returnm <- carteram[dim(carteram)[1], -1] |>\n      as.matrix() |>\n      t()\n    \n    # Calcula a matriz de covarianza\n    \n    covmm <- cov(carteram[, -1], use = \"complete.obs\")\n    npcovmm <- nearPD(covmm)$mat |> \n      as.matrix()\n    \n    # Extrae o número de empresas\n    n <- ncol(npcovmm)\n    \n    # Busca a composición da carteira\n    qp_outm <- solve.QP(\n      Dmat = 2*npcovmm,\n      dvec = rep(0,n),\n      Amat = cbind(-1, diag(n)),\n      bvec = c(-1, rep(0,n)),\n      meq = 1)\n    qp_outm <- qp_outm$solution\n    qp_outm <- floor(qp_outm*100)/100\n    for(j in 1:length(qp_outm)){\n      if(qp_outm[j] < 0.001){\n        qp_outm[j] <- 0\n      }else{}\n    }\n    \n    # Gardar a composición da carteira\n    names(qp_outm) <- names(carteram[, -1])\n    weightsm <- bind_rows(weightsm, qp_outm)\n  }\n  \n  setTxtProgressBar(pb,i)\n}\n\nclose(pb)\n\n# Substitúe os pesos reais e as observacións polos valores que faltan por cero\n\npvtReal[is.na(pvtReal)] <- 0\nweightsm[is.na(weightsm)] <- 0\n```\n\nDespois, para atopar a rendibilidade da carteira, multiplicáronse as composicións polos rendementos reais, supouse que se investiu unha no primeiro período e realizouse unha suma acumulada ao longo dos valores para obter o comportamento da rendibilidade ao longo do período do tempo.\n\n```{r}\n#| eval: false\n\n# Atopar os rendementos das carteiras formadas a partir das predicións da media aritmética\n\nreturn_CM <-  weightsm * pvtReal[-1,-1]\nreturn_CM <- rowSums(return_CM)\nreturn_CM <- c(1,return_CM)\nreturn_CM <- data.frame(\n  Date = pvtReal[,1],\n  Mean = return_CM\n)\n\n```\n\nRealizáronse os mesmos pasos que se realizaron para atopar o comportamento da rendibilidade das carteiras a partir das medias aritméticas para atopar o comportamento a partir das predicións obtidas polo modelo de ARN tal e como se ve no código a continuación.\n\n```{r}\n#| eval: false\n\n# A partir do marco de datos DATA creouse un marco de datos cuxas columnas son os datos obtidos mediante o uso do modelo de ARN de cada unha das empresas para cada un dos períodos de tempo para os que se obtiveron predicións.\n\npvtRNA <- DATA |>\n  select(Date, RNA, ID) |>\n  pivot_wider(\n    names_from = ID,\n    values_from = RNA\n  )\n\n# Creouse o marco de datos no que se almacenaba a composición das carteiras para cada un dos períodos para os que se obtivo a predición.\n\nweightse <- data.frame()\n\n# Iteración pola que se atopa a composición das carteiras\n\npb <- txtProgressBar(min = 0, max = length(unique(data$Date)[-1]), initial = 0, style = 3)\n\nfor (i in 1:length(unique(data$Date)[-1])) {\n  if(i>1){\n    \n    # Créase o marco de datos que inclúe os datos a utilizar para atopar a composición da carteira, esta é creada polos datos reais ata a data e a previsión para o próximo período.\n    \n    dataeQP <- pvtReal |>\n      filter(Date < unique(data$Date)[-1][i]) |>\n      rbind(pvtRNA |>\n              filter(Date == unique(data$Date)[-1][-1][i])\n            )\n    # Elimina aquelas empresas que non teñan datos reais ou previstos\n    \n    nare <- which(is.na(dataeQP[dim(dataeQP)[1],]))\n    naremo <- which(is.na(dataeQP[(dim(dataeQP)[1]-1),]))\n    nare <- c(nare,naremo)\n    nare <- unique(nare)\n    if(length(nare) != 0){\n      carterae <- dataeQP[, - nare]\n    }else{\n      carterae <- dataeQP\n    }\n    \n    # Extraer previsións\n    \n    returne <- carterae[dim(carterae)[1], -1] |>\n      as.matrix() |>\n      t()\n    \n    # Calcula a matriz de covarianza\n    \n    covme <- cov(carterae[, -1], use = \"complete.obs\")\n    npcovme <- nearPD(covme)$mat |> \n      as.matrix()\n    \n    # Extrae o número de empresas\n    \n    n <- ncol(npcovme)\n    \n    # Busca a composición da carteira\n    \n    qp_oute <- solve.QP(\n      Dmat = 2*npcovme,\n      dvec = rep(0,n),\n      Amat = cbind(-1, diag(n)),\n      bvec = c(-1, rep(0,n)),\n      meq = 1)\n    qp_oute <- qp_oute$solution\n    qp_oute <- floor(qp_oute*100)/100\n    for(j in 1:length(qp_oute)){\n      if(qp_outm[j] < 0.001){\n        qp_outm[j] <- 0\n      }else{}\n    }\n    \n    # Gardar a composición da carteira\n    \n    names(qp_oute) <- names(carterae[, -1])\n    weightse <- bind_rows(weightse, qp_oute)\n  }\n  \n  setTxtProgressBar(pb,i)\n}\n\nclose(pb)\n\n# Substitúe os pesos cos valores que faltan por cero\n\nweightse[is.na(weightse)] <- 0\n```\n\nDespois, para atopar a rendibilidade da carteira, multiplicáronse as composicións polos rendementos reais, supouse que se investiu unha no primeiro período e realizouse unha suma acumulada ao longo dos valores para obter o comportamento da rendibilidade ao longo do período. período.tempo.\n\n```{r}\n#| eval: false\n\n# Atopar os rendementos das carteiras formadas a partir das predicións do modelo de ARN\n\nreturn_CRNA <-  weightse * pvtReal[-1,-1]\nreturn_CRNA <- rowSums(return_CRNA)\nreturn_CRNA <- c(1,return_CRNA)\nreturn_CRNA <- data.frame(\n  Date = pvtReal[,1],\n  RNA = return_CRNA\n)\n```\n\nDespois, ao igual que cos indicadores, creouse unha lista `list_ret_RNA` na que se almacenaban os marcos de datos dos distintos modelos construídos con cada unha das estruturas. Despois executouse o seguinte código para obter o gráfico.\n\n```{r}\n#| eval: false\n\n# Coñecer o comportamento das rendibilidades do IBEX para o período\n\nIBEXvals <- IBEXsel |>\n    filter(Date > unique(data$Date)[2]) |>\n    select(2) |>\n    pull()\nIBEXvals <- c(1, IBEXvals)\n\ndata_rent_RNA <- do.call(cbind,list_ret_RNA)\ndata_rent_RNA <- data_rent_RNA |>\n  mutate(\n    Date = RNA1.Date,\n    IBEX = IBEXvals,\n    Means = return_CM$Mean) |>\n  mutate_at(vars(contains(\".RNA\")), ~ cumsum(.)) |>\n  mutate(\n    IBEX = cumsum(IBEX),\n    Means = cumsum(Means)) |>\n  group_by(Date) |>\n  summarize(\n    meanRNA = mean(c_across(contains(\".RNA\"))),\n    max_y = max(c_across(contains(\".RNA\"))),\n    min_y = min(c_across(contains(\".RNA\"))),\n    min_5 = unname(quantile(c_across(contains(\".RNA\")),0.05)),\n    max_95 = unname(quantile(c_across(contains(\".RNA\")),0.95)),\n    IBEX = IBEX,\n    Means = Means)\ndata_rent_RNA |>\n  mutate(\n    Date = as.Date(Date)) |>\nggplot(aes(x = Date)) +\n  geom_ribbon(aes(ymin = min_y, ymax = min_5), fill = \"blue\", alpha = 0.3) +\n  geom_ribbon(aes(ymin = max_y, ymax = max_95), fill = \"blue\", alpha = 0.3) +\n  geom_ribbon(aes(ymin = min_5, ymax = max_95), fill = \"blue\", alpha = 0.6) +\n  geom_line(\n    aes(y = meanRNA, color = \"Media RNA1\"),\n    linetype = \"dashed\") +\n  geom_line(aes(y = max_y), color = \"blue\") +\n  geom_line(aes(y = min_y), color = \"blue\") +\n  geom_line(aes(y = max_95), color = \"blue\") +\n  geom_line(aes(y = min_5, color = \"RNA1\")) +\n  geom_line(aes(y = IBEX, color = \"IBEX\")) +\n  geom_line(aes(y = Means, color = \"Medias\")) +\n  scale_color_manual(\n    values = c(\n      \"Media RNA1\"=\"blue\",\n      \"RNA1\" = \"blue\",\n      \"IBEX\" = \"red\",\n      \"Medias\" = \"green\")) +\n  guides(\n    color = guide_legend(\n      override.aes = list(\n        linetype = c(\"solid\",\"dashed\",\"solid\",\"solid\"))))+\n  labs(x = \"Fecha\",\n       y = \"Valores\",\n       color = \"Leyenda\")+\n  theme_minimal()\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-after-body":["my_scripts.html"],"css":["../my_style.css"],"output-file":"Annex4.html"},"language":{"toc-title-document":"Táboa de contidos","toc-title-website":"Nesta páxina","related-formats-title":"Outros formatos","related-notebooks-title":"Cadernos","source-notebooks-prefix":"Fonte","section-title-abstract":"Abstracto","section-title-appendices":"Anexos","section-title-footnotes":"Notas ao pé","section-title-references":"Referencias","section-title-reuse":"Reutilizar","section-title-copyright":"Dereitos de autor","section-title-citation":"Cita","appendix-attribution-cite-as":"Para a atribución, cite esta obra como:","appendix-attribution-bibtex":"Cita BibTeX:","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliación","title-block-affiliation-plural":"Afiliacións","title-block-published":"Publicado","title-block-modified":"Modificado","callout-tip-title":"Consello","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Precaución","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar todo o código","code-tools-hide-all-code":"Ocultar todo o código","code-tools-view-source":"Ver fonte","code-tools-source-code":"Código fonte","code-line":"Liña","code-lines":"Liñas","copy-button-tooltip":"Copiar ao portapapeis","copy-button-tooltip-success":"Copiouse!","repo-action-links-edit":"Editar esta páxina","repo-action-links-source":"Ver fonte","repo-action-links-issue":"Informar dun problema","back-to-top":"Volver ao inicio","search-no-results-text":"Sen resultados","search-matching-documents-text":"documentos coincidentes","search-copy-link-title":"Copiar ligazón para buscar","search-hide-matches-text":"Ocultar coincidencias adicionais","search-more-match-text":"máis coincidencias neste documento","search-more-matches-text":"máis coincidencias neste documento","search-clear-button-title":"Borrar","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search":"Search","toggle-section":"Alternar sección","toggle-sidebar":"Cambiar navegación da barra lateral","toggle-dark-mode":"Activar o modo escuro","toggle-reader-mode":"Cambia o modo lector","toggle-navigation":"Alternar navegación","crossref-fig-title":"Figura","crossref-tbl-title":"Táboa","crossref-lst-title":"Listado","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolario","crossref-prp-title":"Proposición","crossref-cnj-title":"Conxectura","crossref-def-title":"Definición","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercicio","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apéndice","crossref-sec-prefix":"Sección","crossref-eq-prefix":"Ecuación","crossref-lof-title":"Lista de figuras","crossref-lot-title":"Lista de táboas","crossref-lol-title":"Lista de listados","environment-proof-title":"Proba","environment-remark-title":"Comentario","environment-solution-title":"Solución","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Predeterminado","listing-page-order-by-date-asc":"A máis antiga","listing-page-order-by-date-desc":"O máis novo","listing-page-order-by-number-desc":"De alto a menor","listing-page-order-by-number-asc":"De baixo a maior","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrición","listing-page-field-author":"Autor","listing-page-field-filename":"Nome de arquivo","listing-page-field-filemodified":"Modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de lectura","listing-page-field-categories":"Categorías","listing-page-minutes-compact":"{0} min","listing-page-category-all":"Todos","listing-page-no-matches":"Non hai elementos coincidentes"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","bibliography":["../references.bib"],"editor":"visual","theme":"cosmo","title-block-banner":"#D60D8C","fig-cap-location":"top"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}