{"title":"2.2 Redes neuronais artificiais na previsión de series temporais","markdown":{"headingText":"2.2 Redes neuronais artificiais na previsión de series temporais","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\nEste epígrafe está dividido en tres subtítulos. O primeiro trata sobre os antecedentes do uso de redes neuronais artificiais para traballar con series temporais, máis concretamente na previsión. No segundo e terceiro subtítulo exponse o funcionamento de dúas das estruturas de capa de ARN utilizadas neste traballo, sendo estas a CNN e a LSTM.\n\n## 2.2.1 Antecedentes sobre o uso de redes neuronais artificiais na predición de series temporais\n\nEn @chollet2018deep indícase que o entorno ANN está formado por intelixencia artificial (en diante IA), aprendizaxe automática ou aprendizaxe automática (en diante ML) e aprendizaxe profunda ou aprendizaxe profunda (en diante DL), @fig -DLenv. Por iso, é de vital importancia coñecer os aspectos destes campos que están intimamente relacionados coa RNA e que se explican brevemente a continuación.\n\n\"Facer que unha máquina se comporte de tal forma que un humano sería chamado intelixente\" (@McCarthy_Minsky_Rochester_Shannon_2006, p.11) é a primeira definición que se dá ao problema da IA. Co obxectivo de resolver este problema xurdiu a primeira IA, a chamada IA ​​simbólica.\n\nComo explicaron @haykin1998neural, @banda2014 e @chollet2018deep, estas primeiras IAs implicaban regras codificadas creadas polos programadores. Co obxectivo de conseguir que estas regras fosen aprendidas automaticamente polas máquinas ao observar os datos, xurdiu unha nova etapa no desenvolvemento da IA, a denominada ML. Esta nova etapa dá lugar á aparición dunha nova forma de programación, diferenciada da clásica, na medida en que, nesta, os programadores introducen os datos e as respostas esperadas a eles, e os ordenadores son capaces de xerar as regras, @fig-MLprog.\n\nPolo tanto, enténdese que os modelos de ML intentan atopar representacións axeitadas para os seus datos de entrada: transformacións dos datos que o fan máis apto para a tarefa en cuestión. En DL, que é un subcampo específico de ML, estas representacións de datos modelízanse mediante arquitecturas compostas por capas sucesivas, que se denominan ARN @chollet2018deep.\n\nDespois de estudar o que se expuxo en @haykin1998neural, @Larranaga07, @banda2014 e @chollet2018deep sobre ANN, pódese afirmar que están inspirados no funcionamento do cerebro humano, estes textos confirman e coinciden en que se poden distinguir tres tipos de ANN capas. : entrada, saída e oculta. Unha capa de entrada está composta por neuronas que reciben os vectores de entrada. Unha capa de saída está formada por neuronas que, durante o adestramento, reciben os vectores de saída e despois xeran a resposta. Unha capa oculta está conectada ao ambiente a través das capas de entrada e saída, este tipo de capa oculta procesa a entrada recibida para obter a saída correspondente, @fig-RNAstruct.\n\nUnha das aplicacións da ANN é a previsión de series temporais. cuxo obxectivo é predicir os valores futuros das variables en función das súas observacións pasadas. Como se comentou anteriormente, as series temporales financeiras adoitan ser non lineais, ruidosas, caóticas e non estacionarias, o que dificulta a súa modelización e previsión. As ANN teñen a vantaxe de poder captar relacións non lineais complexas e adaptarse ás condicións cambiantes sen esixir presupostos previos sobre a distribución ou estrutura dos datos.\n\nA historia das ANN na previsión de series temporais financeiras remóntase a finais dos 80 e principios dos 90, cando os investigadores comezaron a explorar o potencial das ANN como alternativa aos métodos estatísticos tradicionais, como o modelo de media móbil autorregresiva integrada, máis coñecido como ARIMA. Autoregresivo Integrado Moving Average) e modelos autorregresivos xeneralizados con heterocedasticidade condicional, máis coñecidos como GARCH (Heterocedasticidade Condicional Autorregresiva Xeneralizada). Demostrouse que as ANN teñen varias vantaxes sobre estes métodos, como a capacidade de capturar relacións non lineais e dinámicas, manexar datos ruidosos e incompletos e adaptarse ás condicións cambiantes do mercado (@ZHANG199835).\n\nNon obstante, as ANN tamén se enfrontan a algunhas limitacións e desafíos na previsión de series temporais financeiras, como a dificultade de escoller unha arquitectura de rede adecuada, un algoritmo de adestramento, a función de activación e as variables de entrada; o risco de problemas de sobreadaptación e xeneralización; a falta de interpretabilidade e transparencia; e o alto custo e tempo computacional (@TEALAB2018334).\n\nPara superar estas limitacións e desafíos, os investigadores propuxeron varias melloras e ampliacións de ANN para a previsión de series temporais financeiras nas últimas décadas. Algúns dos principais desenvolvementos inclúen:\n\n-   O uso de modelos híbridos que combinan ANN con outras técnicas como a lóxica difusa, algoritmos xenéticos, análise de wavelets, máquinas vectoriais de soporte e aprendizaxe profunda para mellorar o rendemento e a robustez da ANN (@wongguo2010).\n\n-   O uso de redes neuronais recorrentes (en diante RNR) ou bidireccionais, que son un tipo especial de ANN que poden procesar datos secuenciais e capturar dependencias temporais. Demostrouse que os RNR superan as redes neuronais unidireccionais en series temporales complexas e non lineais (@GURESEN201110389).\n\n-   O uso de modelos de ARN máis complexos mediante a combinación de diferentes capas, como redes neuronais convolucionais (en diante, CNN), memoria a longo prazo (en diante, LSTM), unidades recorrentes gated (en diante GRU) aplicouse á previsión de series temporais financeiras con resultados prometedores (@SEZER2020106181).\n\nA historia das ANN na previsión de series temporais financeiras mostra que as ANN evolucionaron e melloraron co paso do tempo para facer fronte á complexidade e incerteza dos mercados financeiros. Non obstante, aínda persisten algúns dos desafíos e limitacións mencionados anteriormente, como o sobreajuste, a xeneralización, a interpretabilidade, a robustez e o custo computacional.\n\n## 2.2.2 Redes neuronais convolucionais\n\nO modelo de ARN empregado neste traballo está composto por varias capas, sendo a máis importante a capa Conv1D, un tipo específico de CNN, e a capa LSTM, ambas as mencionadas no subapartado anterior cando as estruturas ANN que máis se utilizan na actualidade. Esta subsección céntrase na Capa Conv1D, polo que se exploran os conceptos fundamentais para comprender o seu funcionamento, explicando a convolución, as redes neuronais convolucionais e Conv1D e o seu uso para a análise de series temporais. Ofrécese unha visión xeral da convolución e como se pode aplicar aos datos de series temporais. Despois, fálase das CNN e da súa arquitectura, que lles permite aprender automaticamente funcións a partir de datos de series temporais. Finalmente, explícase Conv1D, un tipo específico de capa de rede neuronal convolucional que é particularmente eficaz para procesar datos de series temporais.\n\nComo se comenta en @rafid23, a convolución é unha operación matemática que se usa habitualmente no procesamento de sinal e análise de imaxes. Implica tomar dúas funcións e producir unha terceira función que representa como unha das funcións orixinais modifica a outra. No contexto dos datos de series temporais, a convolución pódese usar para extraer características dos datos aplicando un filtro á serie temporal.\n\nAdemais de extraer funcións dos datos de series temporais, a convolución tamén se pode usar para outras tarefas como a redución de ruído, a detección de anomalías e a predición. Por exemplo, unha CNN pódese adestrar para predecir os valores futuros dunha serie temporal aprendendo os patróns subxacentes nos datos. En xeral, a convolución é unha poderosa ferramenta para analizar datos de series temporais e as súas aplicacións son numerosas @rafid23.\n\nAs CNN introducíronse por primeira vez en @cnn e son un tipo de modelo de aprendizaxe profunda que se usa habitualmente para a análise de imaxes. Non obstante, como se mencionou anteriormente, tamén se poden usar para a análise de series temporais, xa que son moi axeitados para aprender características a partir de datos que teñen unha estrutura espacial ou temporal.\n\nA arquitectura dunha CNN consta dunha ou máis capas convolucionais, que aplican filtros aos datos de entrada para extraer características. Cada filtro é un conxunto de pesos que se aprenden durante o proceso de adestramento. Ao desprazar o filtro sobre os datos de entrada, a capa convolucional calcula un produto puntual en cada posición, producindo un novo mapa de características @cnn.\n\nNun contexto de series temporais, unha CNN pode aprender a extraer automaticamente características dos datos a diferentes escalas e intervalos de tempo, o que o converte nunha poderosa ferramenta para a análise de series temporais. Unha vantaxe fundamental de usar unha CNN para a análise de series temporais é que reduce a necesidade de enxeñería manual de funcións. En lugar de deseñar filtros a man, CNN aprende a extraer automaticamente funcións dos datos, facéndoos máis flexibles e adaptables a diferentes tipos de datos de series temporais.\n\nEn xeral, a arquitectura dunha CNN permítelle aprender automaticamente características dos datos de series temporais, o que o converte nunha poderosa ferramenta para a análise de series temporais, sendo Conv1D unha das estruturas de CNN máis utilizadas para esta tarefa.\n\nComo se explica en @hongj20, Conv1D é un tipo específico de capa CNN que está deseñada para procesar datos unidimensionales, como datos de series temporais. Mentres que as CNN tradicionais están deseñadas para procesar datos bidimensionais, Conv1D está optimizado especificamente para datos unidimensionais, o que o fai máis eficiente e eficaz para a análise de series temporais.\n\nA arquitectura dunha capa Conv1D é similar á dunha CNN tradicional, pero con algunhas diferenzas clave. En lugar de usar filtros bidimensionais, Conv1D usa filtros unidimensionais, que se aplican á serie temporal de entrada para extraer características. As características que se extraen da cadea dependerán das diferentes configuracións utilizadas para a configuración do filtro e do número de filtros empregados, sendo a seguinte fórmula para calcular a cantidade de característica que extrae cada filtro: @eq-cnn-lout (@hongj20):\n\n$$\n\\begin{aligned}\nL_{out} &= \\frac{L_{in} + 2*padding - dilation*(kerenel\\_size - 1)-1}{stride} + 1 \\\\\n\\end{aligned}\n$$ {#eq-cnn-lout}\n\nOnde:\n\n::: margin\n*Lout*: é a lonxitude da saída do proceso de filtrado ou o número de funcións.\n:::\n\n::: margin\n*Lin*: a lonxitude do vector de entrada, correspondente na análise de series temporais ao número de observacións que conteñen as mostras da serie temporal que se pasan ao filtro.\n:::\n\n::: margin\n*kernel_size*: é o tamaño do filtro, que define cantas observacións do vector de entrada se pasan ao filtro cada vez. @fig-HJks representa como o tamaño do filtro pode afectar a lonxitude do vector de saída.\n:::\n\n::: margin\n*stride*: representa o número de pasos ou observacións polos que se move a selección de observacións pasadas ao filtro. @fig-HJstride representa como o parámetro stride pode afectar a lonxitude do vector de saída.\n:::\n\n::: margin\n*dilation*: é a distancia das observacións que pasan polo filtro. @fig-HJdilation representa como o parámetro de dilatación pode afectar a lonxitude do vector de saída.\n:::\n\n::: margin\n*padding*: representa o número de ceros a engadir a cada extremo do vector. @fig-HJpadding representa como o parámetro de recheo pode afectar a lonxitude do vector de saída.\n:::\n\nEn xeral, Conv1D é unha poderosa ferramenta para procesar datos de series temporais e as súas vantaxes inclúen a eficiencia computacional e a capacidade de capturar dependencias de tempo nos datos. Os seus casos de uso son numerosos e abarcan diferentes campos, polo que é unha ferramenta valiosa para a análise de series temporais.\n\n## 2.2.3 Long short-term memory\n\nEsta subsección explica por que os LSTM son unha das estruturas ANN máis utilizadas na predición de series temporais, baseándose nunha breve explicación dos RNR e por que son útiles para resolver problemas de predición de series. as RNN, e o funcionamento de cada unha das capas que conforman a estrutura dunha capa LSTM.\n\n@COlah15 explica que unha RNN pode considerarse como varias copias da mesma rede, @fig-CORNRstruct, afirma que este aspecto revela que os RNR están íntimamente relacionados con secuencias e listas, o que fai que este tipo de ARN sexa o que naturalmente se utiliza para traballar con series temporais.\n\nOs RNR convencionais presentan un problema en relación coa capacidade de reter información, como explica @COlah15, os RNN estándar só funcionan con gran capacidade se a información relevante para a situación actual é recente, é dicir, onde a brecha entre a información relevante e onde se é necesario é pequeno, @fig-CORInclose; ademais expón que a medida que a brecha crece, os RNN estándar non poden acceder á información relevante, @fig-CORInaway.\n\nComo se mencionou anteriormente, os LSTM son un tipo de RNR que pode aprender dependencias a longo prazo dos datos secuenciais. Estes foron propostos en @SeppJur97 e foron moi utilizados para varias tarefas como modelado de linguaxe, recoñecemento de voz, tradución automática, descrición de imaxes e previsión de series temporais.\n\nA idea principal de LSTM é introducir unha célula de memoria que poida almacenar e actualizar información en pasos longos. A cela de memoria está controlada por tres portas: unha porta de entrada, unha porta de esquecemento e unha porta de saída. Estas portas son redes neuronais que aprenden a regular o fluxo de información dentro e fóra da célula @fig-CODrnrlstm.\n\nA porta de entrada decide canto da nova entrada engadir ao estado da cela. A porta de esquecemento decide que parte do estado da cela anterior manter ou eliminar. A porta de saída decide que parte do estado da cela actual se enviará á seguinte capa. @COlah15 baseándose no exposto en @SeppJur97, describe o funcionamento das portas en catro pasos:\n\n1.  Decidindo que información do estado da cela se esquece a través da porta, esquece a capa de porta $f_t$. Esta porta mira $h_{t-1}$, estado oculto do período de tempo anterior, e $x_{t}$, entrada do instante de tempo actual, e mostra un número entre 0 (desfacer) e 1 (mantener) . para cada número no estado da cela $C_{t-1}$, @fig-COLSTMstep1, @eq-lstm-fstep.\n\n$$\n\\begin{aligned}\nf_t &= \\sigma(W_f [h_{t-1}, x_t] + b_f) \\\\\n\\end{aligned}\n$$ {#eq-lstm-fstep}\n\n2.  Decida que información nova se almacena no estado da cela. Para isto primeiro, a capa de porta de entrada decide que valores actualizar e despois unha capa tanh (tanxente hiperbólica) crea un vector de novos valores candidatos ($\\tilde{C}_t$) que se poden engadir ao estado, @fig-COLSTMstep2, @eq-lstm-sstepf y @eq-lstm-ssteps.\n\n$$\n\\begin{aligned}\ni_t &= \\sigma(W_i [h_{t-1}, x_t] + b_i) \\\\\n\\end{aligned}\n$$ {#eq-lstm-sstepf}\n\n$$\n\\begin{aligned}\n\\tilde{C}_t &= tanh(W_c [h_{t-1}, x_t] + b_c) \\\\\n\\end{aligned}\n$$ {#eq-lstm-ssteps}\n\n3.  O estado da cela antiga, $C_{t-1}$, actualízase ao novo estado da cela $C_{t}$. Multiplica o estado anterior por $f_{t}$, esquecendo o que é necesario, despois engade $i_{t} * \\tilde{C}_{t}$. Estes son os novos valores candidatos, escalados pola cantidade de cada valor de estado que se debe actualizar, @fig-COLSTMstep3, @eq-lstm-tstep.\n\n$$\n\\begin{aligned}\nC_t &= f_t * C_{t-1} + i_t * \\tilde{C}_t  \\\\\n\\end{aligned}\n$$ {#eq-lstm-tstep}\n\n4.  Xérase unha saída en función do estado da cela. Executar primeiro unha capa sigmoide que decide que partes do estado da célula é a saída; entón o estado da cela pásase a través dunha función tanh (escalando os valores entre -1 e 1) e multiplícase pola saída da porta, porta de saída, @fig-COLSTMstep4, @eq-lstm-fstepf y @eq-lstm-fsteps.\n\n$$\n\\begin{aligned}\no_t &= \\sigma(W_o [h_{t-1}, x_t] + b_o) \\\\\n\\end{aligned}\n$$ {#eq-lstm-fstepf} $$\n\\begin{aligned}\nh_t &= o_t * tanh(C_t) \\\\\n\\end{aligned}\n$$ {#eq-lstm-fsteps}\n\nOs LSTM poden aprender a capturar dependencias a longo prazo axustando os valores de porta a través da propagación posterior. Por exemplo, se unha determinada entrada é relevante para unha saída posterior, a porta de entrada aprenderá a deixala entrar e a porta esquecida aprenderá a mantela no estado da cela ata que sexa necesaria. Pola contra, se unha entrada é irrelevante ou obsoleta, a pasarela aprenderá a ignorala e a porta esquecida aprenderá a eliminala do estado da cela.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-after-body":["my_scripts.html"],"css":["../my_style.css"],"output-file":"ANNinTSF.html"},"language":{"toc-title-document":"Táboa de contidos","toc-title-website":"Nesta páxina","related-formats-title":"Outros formatos","related-notebooks-title":"Cadernos","source-notebooks-prefix":"Fonte","section-title-abstract":"Abstracto","section-title-appendices":"Anexos","section-title-footnotes":"Notas ao pé","section-title-references":"Referencias","section-title-reuse":"Reutilizar","section-title-copyright":"Dereitos de autor","section-title-citation":"Cita","appendix-attribution-cite-as":"Para a atribución, cite esta obra como:","appendix-attribution-bibtex":"Cita BibTeX:","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliación","title-block-affiliation-plural":"Afiliacións","title-block-published":"Publicado","title-block-modified":"Modificado","callout-tip-title":"Consello","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Precaución","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar todo o código","code-tools-hide-all-code":"Ocultar todo o código","code-tools-view-source":"Ver fonte","code-tools-source-code":"Código fonte","code-line":"Liña","code-lines":"Liñas","copy-button-tooltip":"Copiar ao portapapeis","copy-button-tooltip-success":"Copiouse!","repo-action-links-edit":"Editar esta páxina","repo-action-links-source":"Ver fonte","repo-action-links-issue":"Informar dun problema","back-to-top":"Volver ao inicio","search-no-results-text":"Sen resultados","search-matching-documents-text":"documentos coincidentes","search-copy-link-title":"Copiar ligazón para buscar","search-hide-matches-text":"Ocultar coincidencias adicionais","search-more-match-text":"máis coincidencias neste documento","search-more-matches-text":"máis coincidencias neste documento","search-clear-button-title":"Borrar","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search":"Search","toggle-section":"Alternar sección","toggle-sidebar":"Cambiar navegación da barra lateral","toggle-dark-mode":"Activar o modo escuro","toggle-reader-mode":"Cambia o modo lector","toggle-navigation":"Alternar navegación","crossref-fig-title":"Figura","crossref-tbl-title":"Táboa","crossref-lst-title":"Listado","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolario","crossref-prp-title":"Proposición","crossref-cnj-title":"Conxectura","crossref-def-title":"Definición","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercicio","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apéndice","crossref-sec-prefix":"Sección","crossref-eq-prefix":"Ecuación","crossref-lof-title":"Lista de figuras","crossref-lot-title":"Lista de táboas","crossref-lol-title":"Lista de listados","environment-proof-title":"Proba","environment-remark-title":"Comentario","environment-solution-title":"Solución","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Predeterminado","listing-page-order-by-date-asc":"A máis antiga","listing-page-order-by-date-desc":"O máis novo","listing-page-order-by-number-desc":"De alto a menor","listing-page-order-by-number-asc":"De baixo a maior","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrición","listing-page-field-author":"Autor","listing-page-field-filename":"Nome de arquivo","listing-page-field-filemodified":"Modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de lectura","listing-page-field-categories":"Categorías","listing-page-minutes-compact":"{0} min","listing-page-category-all":"Todos","listing-page-no-matches":"Non hai elementos coincidentes"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","bibliography":["../references.bib"],"editor":"visual","theme":"cosmo","title-block-banner":"#D60D8C","fig-cap-location":"top"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}